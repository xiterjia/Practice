## 设计模式类别

1. 创建型设计模式

   - Constructor(构造器) √
   - Factory(工厂) √
   - Abstract(抽象)
   - Prototype(原型) √
   - Singleton(单例) √
   - Builder(生成器)

2. 结构型设计模式

   - Decorator(装饰者)
   - Facade(外观)
   - Flyweight(享元)
   - Adapter(适配器)
   - Proxy (代理)

3. 行为设计模式
   - Iterator(迭代器)
   - Mediator(中介者)
   - Observer(观察者)
   - Visitor(访问者)

## 设计模式分类

| 创建型模式 | 基于创建对象的概念                                      |
| ---------- | ------------------------------------------------------- |
| 类         |                                                         |
| 工厂方法   | 基于接口数据或事件生成几个派生类的一个实例              |
| 对象       |                                                         |
| 抽象工厂   | 创建若干类系列的一个实例,无需详述具体的类               |
| 生成器     | 从表示中分离对象构建;总是创建相同类型的对象             |
| 原型       | 用于复制或克隆完全初始化的实例                          |
| 单例       | 一个类在全局访问点只有唯一一个实例                      |
| 结构型模式 | 基于构建对象块的想法                                    |
| 类         |                                                         |
| 适配器     | 匹配不同类的接口,因此类可以在不兼容接口的情况下共同工作 |
| 对象       |                                                         |
| 适配器     | 匹配不同类的接口,因此类可以在不兼容接口的情况下共同工作 |
| 桥接       | 将对象接口从其实现中分离,因此它们可以独立进行变化       |
| 组合       | 简单和复合对象的结构,使对象的总和不只是它各部分的总和   |
| 装饰       | 向对象动态添加备选的处理                                |
| 外观       | 隐藏整个子系统复杂性的唯一一个类                        |
| 享元       | 一个用于实现包含在别外信息的高效共享的细粒度实例        |
| 代理       | 占位符对象代表真正的对象                                |
| 行为模式   | 基于对象在一起配合工作的方式                            |
| 类         |                                                         |
| 解释器     | 将语言元素包含在应用程序中的方法,以匹配预期语言的语法   |
| 模板方法   | 在方法中创建算法的 shell,然后将确切的步骤推到子类       |
| 对象       |                                                         |
| 职责链     | 在对象链之间传递请求的方法,以找到能够处理请求的对象     |
| 命令       | 将命令执行从其调用程序中分离的方法                      |
| 迭代器     | 顺序访问一个集合中的元素,无需了解该集合的内部工作原理   |
| 中介者     | 在类之间定义简化的通信,以防止一级类显式引用彼此         |
| 备忘录     | 铺货对象的内部状态,以能够在以后恢复它                   |
| 观察者     | 向多个类通知改变的方法,以确保类之间的一致性             |
| 状态       | 状态改变时,更改对象的行为                               |
| 策略       | 在一个类中封闭算法,将选择与实现分离                     |
| 访问者     | 向类添加一个新的操作,无需改变类                         |
